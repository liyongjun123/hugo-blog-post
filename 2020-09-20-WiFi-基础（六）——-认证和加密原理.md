---
title: "WiFi 基础（六）—— 认证和加密原理"
date: 2020-09-20T01:22:15+08:00
draft: false
categories: ["无线"]
tags: ["Wi-Fi"]
toc: false
url: "/2020/09/20/wifi-basic-authentication-and-encryption-principle.html"
---

## 认证和加密

WiFi 连接过程其实主要就做了两件事：身份认证和密钥交换

## 为什么要进行身份认证

为了只让特定(合法)用户使用当前网络

## 为什么要进行密钥交换

为了使用加密的方式进行通信，防止通信信息被第三方截获破解导致隐私泄露

## 如何进行身份认证

只要让 AP 知道 STA 中储存的密码是否和自己的密码相等就可以了。最简单的办法：拿到 STA 的密码。AP 将其和自己的密码进行比对，相等则代表该 STA 是合法用户，应当准许接入网络，否则，应当拒绝接入。

AP 怎样拿到 STA 的密码呢？1：STA 将密码明文传输，2：STA 将密码加密传输。第 1 种方法：密码明文发送给 AP，AP 收到后确实可以验证 STA 的身份合法性，但是由于密码是明文传输的，相当于向当前空间区域广播了此网络的密码，这样别的 STA 也可以轻松地收到密码并加入当前网络。这样其它本来非法的用户也变得合法了，显然这种方式是不可取的。那第 2 种方法呢：将密码加密传输。那试问 STA 将密码加密了，它们俩之间又实现没有同步密钥，AP 拿到数据也解不出密码呀，这种方案显然也是不可取的。

那能在不泄露密码的情况下达到身份认证的目的吗？当然可以，我们以 WPA 方式举例，WPA 的身份认证其实是在 EAPOL 阶段，采用的是 4-way handshake 手段，如下

![image-20200920011731020](/images/EAPOL过程.png)

其底层数学原理是哈希算法。公式如下
$$
PTK=PRF(AA, SA, ANonce, SNonce, PMK)
$$
```shell
PTK 就是加密用的密钥
PRF 可以简单理解为 sha1 算法
AA 是 Authenticator(认证者) 的 MAC 地址
SA 是 Supplicant(申请者)的 MAC 地址
ANonce 是 Authenticator 产生的随机字串
SNonce 是 Supplicant 产生的随机字串
PMK 是由密码和 SSID 信息生成的密钥，如果 STA 和 AP 拥有相同的密码，则此密钥值也会相同，反之也成立。
```



AP 和 STA 使用相同的算法对五元组(AA, SA, ANonce, SNonce, PMK)进行计算，其中 AA、SA、ANonce、SNonce 都已通过报文的形式明文传递成功，若两者的 PMK 相同，则就能够产生相同的 PTK ，此后还可用 PTK 对数据进行加密。那么如何确定两者拥有相同的 PTK 呢？当然不能明文传输去比较，我们进行如下操作，在操作之前，我们先对 PTK 进行如下划分
$$
PTK = KCK + KEK + TK
$$
其中：

```shell
KCK = L(PTK, 0, 128)
KEK = L(PTK, 128, 128)
TK = L(PTK, 256, TK_bits)
```



操作如下

用 KCK 对传输的数据进行计算得到 MIC，AP 收到数据后，也拿自身的 KCK 对传输的数据进行计算得到 MIC，若收到的 MIC 和 自己计算的 MIC 相等，则表明 KCK 相等，进一步表明 PTK 相等(两个 512bits 的PTK，前 128 bits 完全相等，则有理由相信两个 PTK 的所有 bit 都是相等的)。

以上，既完成了身份认证，又完成了密钥交换。

## PS：完整性

其实，上述过程不仅能够确认身份合法、密钥成功交换，在接下来的数据通信中，还能保证数据的完整性，因为报文中的 MIC 位的功能本身就是信息完整性检验。

