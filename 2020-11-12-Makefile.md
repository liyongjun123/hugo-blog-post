---
title: "Makefile"
date: 2020-11-12T21:05:53+08:00
draft: false
categories: ["C"]
tags: ["学习"]
toc: false
url: /2020/11/12/makefile.html
---

## Makefile 的文件名

默认情况下，make 命令会在当前目录下按顺序寻找文件名为 “GNUmakefile”、"makefile"、"Makefile" 的文件，找到了解释这个文件。

在这三个文件名中，**最好使用** "Makefile" 这个文件名，因为，这个文件名第一个字母为大写，比较醒目。**最好不使用** “GNUmakefile”，这个文件是 GNU 的 make 识别的。有另外一些 make 只对全小写的 "makefile" 文件名敏感，但基本上来说，大多数的 make 都支持 "makefile" 和 "Makefile" 这两种默认文件名。

当然，可以使用别的文件名来书写 Makefile，比如 “Make.Linux”，这样就要使用 "-f" 或 "--file" 参数，如：`make -f Make.Linux` 或 `make --file Make.Linux`

## 引用其它的 Makefile

在 Makefile 文件中使用 include 关键字可以把别的 Makefile 文件包含进来，这很像 C 语言的 #include，被包含的文件会原模原样的放在当前文件的 include 位置。

## 面向依赖关系

写一个 Makefile 文件的第一步不是一个猛子扎进区试着写一个规则，而是先用面向以来关系的方法想清楚，所要写的 Makefile 需要表达什么杨的依赖关系。

运用依赖关系去思考，在写 Makefile 时，头脑会非常清楚自己在写什么，以及后面要写什么。

所以，先抛开 Makefile，看一看源代码的依赖关系是什么。

## 规则

```makefile
taget ... : prerequisites
	command
	...
	...
```





## 目标 && 伪目标

- **目标**是一个文件

- **伪目标**不是一个文件，只是一个标签

目标不一定每次都被执行，因为其依赖可能没有被修改。但是伪目标必然会被执行。

可以想像目标与文件关联，伪目标不与文件关联。

使用 `.PHONY` 来显式地指明一个目标是 “伪目标”。

## 自动化变量

- **$@** 用于表示一个规则中的目标。
- **$^** 则表示的是规则中的所有先择条件。
- **$<** 表示了所有依赖目标的挨个值。

## 命令

### 命令出错



























